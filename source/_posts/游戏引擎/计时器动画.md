有一个解决方法就是计时器的循环体的方法可能已经开始执行，在循环体前面加一个bool的判断进行阻断。
```C#
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class Benevolence : MonoBehaviour
{
    [SerializeField]
    private RectTransform BigRectTransform; // 用于存储大爱心RectTransform组件的引用

    [SerializeField]
    private GameObject up;

    [SerializeField]
    private GameObject middle;

    [SerializeField]
    private GameObject bottom;

    [SerializeField]
    RectTransform upRectTransform;

    [SerializeField]
    RectTransform middleRectTransform;

    [SerializeField]
    RectTransform bottomRectTransform;

    public TimeAction upLoveAction;
    public TimeAction middleAction;
    public TimeAction bottomAction;
    public TimeAction bigAction;

    public float moveDistance = 10.0f; // 每次移动的距离（像素）


    private void Awake()
    {
        InitializeTimers();
    }

    private void InitializeTimers()
    {
        upLoveAction = GameEntry.Time.CreateTimeAction();
        middleAction = GameEntry.Time.CreateTimeAction();
        bottomAction = GameEntry.Time.CreateTimeAction();
        bigAction = GameEntry.Time.CreateTimeAction();

        #region 第一个爱心直接过去
        upLoveAction.Init(0, 0.1f, 10, () =>
        {
            upRectTransform.gameObject?.SetActive(true);
            upRectTransform.anchoredPosition = new Vector2(0, 0);
            middleAction.Run();
        }, (int loop) =>
        {
            upRectTransform.anchoredPosition += new Vector2(moveDistance, 11);
        }, () =>
        {
            // 爱心闪烁一下
            bigAction.Run();
            upRectTransform.gameObject?.SetActive(false);
        });
        #endregion

        #region 第二个爱心直接过去，0.2秒后执行
        middleAction.Init(0.2f, 0.1f, 10, () =>
        {
            middleRectTransform.gameObject?.SetActive(true);
            middleRectTransform.anchoredPosition = new Vector2(0, 0);
            bottomAction.Run();
        }, (int loop) =>
        {
            middleRectTransform.anchoredPosition += new Vector2(moveDistance, 11);
        }, () =>
        {
            middleRectTransform.gameObject?.SetActive(false);
            // 爱心闪烁一下
            bigAction.Run();
        });
        #endregion

        #region 第三个爱心直接过去,0.2秒后执行
        bottomAction.Init(0.2f, 0.1f, 10, () =>
        {
            bottomRectTransform.gameObject?.SetActive(true);
            bottomRectTransform.anchoredPosition = new Vector2(0, 0);
        }, (int loop) =>
        {
            bottomRectTransform.anchoredPosition += new Vector2(moveDistance, 11);
        }, () =>
        {
            bottomRectTransform.gameObject?.SetActive(false);
        });
        #endregion

        #region 大爱心闪烁
        bigAction.Init(0, 0.1f, 3, () =>
        {
            BigRectTransform.sizeDelta = new Vector2(70, 62);
        }, (int loop) =>
        {
            BigRectTransform.sizeDelta = new Vector2(86, 75);
        }, () =>
        {
            BigRectTransform.sizeDelta = new Vector2(70, 62);
        });
        #endregion
    }

    public void StartTimers()
    {
        upLoveAction.Run();
    }

    private void OnDestroy()
    {
        CleanupTimers();
    }

    private void CleanupTimers()
    {
        if (upLoveAction != null)
        {
            //upLoveAction.Stop(false);
            upLoveAction = null;
            upRectTransform = null;
        }
        if (middleAction != null)
        {
            //middleAction.Stop(false);
            middleAction = null;
            middleRectTransform = null;
        }
        if (bottomAction != null)
        {
            //bottomAction.Stop(false);
            bottomAction = null;
            bottomRectTransform = null;
        }
        if (bigAction != null)
        {
            //bigAction.Stop(false);
            bigAction = null;
            BigRectTransform = null;
        }
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        print("被点击了吗");
        upLoveAction.Run(); // 如果需要在此处重新启动某个动作，请确保该动作已经被正确初始化。
    }
}

```