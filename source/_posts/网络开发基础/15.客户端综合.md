使用Socket客户端知识结合多线程实现1.客户端网络连接不会影响主线程，2.可以随时和服务端进行通信

在Unity客户端中新建脚本
```C#
public class NetMgr : MonoBehaviour
{
	private static NetMgr instance;
	public static NetMgr Instance => instance;
	// 客户端Socket
	private Socket socket;
	// 用于发送消息的队列公共容器，主线程往里面放，发送线程从里面取出来
	private Queue<string> sendMsgQueue = new Queue<string>();
	// 用于接受信息的对象，公共容器，子线程往里面放，主线程往里面取
	private Queue<string> receiveMsgQueue = new Queue<string>();
	private Thread sendThread; // 发送线程  
	// 收消息的水桶（容器）
	private byte[] receiveBytes = new byte[1024*1024];
	// 返回收到的字节数
	private int receiveNum;
	void Awake()
	{
		instance = this;
	}
	void Update()
	{
	
	}
	// 连接服务器
	public void Connect(string ip,int port)
	{
		if(socket == null)
			socket = new Socket(AddressFamily.InterNetWork,Socket.Stream,ProtocolType.Tcp);
		IPEndPoint ipPoint = new IPEndPoint(IPAddress.Parse(ip),port);
		try
		{
			socket.Connect(ipPoint);
			// 开启发送线程
			sendThread = new Thread(SendMsg);
			sendThread.Start();
		}
		catch (SocketException e)
		{
			if(e.ErrorCode == 10061)
				print("服务器拒绝连接");
			else
				print("连接失败" + e.ErrorCode + e.Message);
		}
	}
	// 发送消息
	public void Send(string info)
	{
		sendMsgQueue.Enqueue(info);
	}
	private void SendMsg()
	{
		while(true)
		{
			if(sendMsgQueue.Count>0)
			{
				socket.Send(Encoding.UTF8.GetBytes(sendMsgQueue.Dequeue()));
			}
		}
	}
	private void ReceiveMsg()
	{
		while (true)
		{
			if(socket.Available > 0)
			{
				receiveNum = socket.Receive(receiveBytes);
				// 收到消息，解析消息为字符串, 并放入公共容器
				receiveQueue.Enqueue(Encoding.UTF8.GetString(receiveBytes,0,receiveNum));
			}
		}
	}
}
```