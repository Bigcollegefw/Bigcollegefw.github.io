1.使用Socket服务端编程基础知识结合多线程知识点实现服务端服务多个客户端
多个客户端可以连接，可以分别和多个客户端进行通信
```C#
class Program
{
	static Socket socket;
	static List<Socket> clientSockets = new List<Socket>(); // 存储客户端连入的Socket
	static bool isClose = false;
	static void Main(string[] args)
	{
	// 1.建立Socket 绑定 监听
		socket = new Socket(AddressFamily.InterNetwork,SocketType.Stream,ProtocolType.Tcp);
		IPEndPoint ipPoint = new IPEndPoint(IPAddress.Parse("127.0.0.1"),8080);
		socket.Bind(ipPoint);
		socket.Listen(1024);
	// 2.等待客户端连接，特别处理
		Thread acceptThread = new Thread(AcceptClientConnent);
		acceptThread.Start();
	// 3.收发消息,特别处理  
		Thread receiveThread = new Thread(ReceiveMsg);
		receiveThread.Start();
	// 4.关闭相关
		while(true)
		{
			string input = Console.ReadLine();
			if(input == "Quit")
			{
				isClose = true;
				for(int i = 0;i<clientSockets.Count;i++) 
				{
					clientSockets[i].Shutdown(SocketShutdown.Both);
					clientSockets[i].Close();
				}
				clientSockets.Clear();
				break;
			}
		}
	}
	static void AcceptClientConnent()
	{
		while(!isClose)
		{
			Socket clientSocket = socket.Accept();
			clientSockets.Add(clientSocket);
			clientSocket.Send(Encoding.UTF8.GetBytes("欢迎连入服务端"));	
		}
	}
	static void ReceiveMsg()
	{
		Socket clientSocket;
		byte[] result = new byte[1024*1024];
		int receiveNum;
		int i;
		while(!isClose)
		{
			for(i = 0;i<clientSockets.Count;i++)
			{
				clientSocket = clientSockets[i];
				// 判断该socket是否有可以接收的信息，返回值就是字节数
				if(clientSocket.Available > 0)
				{
					// 客户端即使没有发消息过来，这句代码也会执行，会造成性能损耗，所以加判断。
					receiveNum = clientSocket.Receive(result);
					// 如果在这收到消息就处理可能造成别人消息处理不及时
					ThreadPool.QueueUserWorkItem(HandleMsg,(clientSocket,Encoding.UTF8.GetString(result,0,receiveNum)));// 线程池
				}
			}
		}
	}
	static void HandleMsg(object obj)
	{
		(Socket s,string str) info = ((Socket s,string str))obj;
		Console.WriteLine("收到客户端{0}发来的信息：{1}",info.s.RemoteEndPoint,info.str);
	}
}
```
2.用面向对象的思想对服务端的客户端Socket进行封装
添加一个类ClientSocket
```C#
class ClientSocket
{
	public Socket socket;


}
```