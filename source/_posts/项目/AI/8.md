using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEditor.Timeline.Actions;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class EnemyObject : MonoBehaviour
{
    public enum State
    {
        Idle,
        Injured
    }

    [SerializeField]
    private GameObject player; // 玩家引用
    [SerializeField]
    private Sprite[] idleSprites; // 普通状态动画帧序列
    [SerializeField]
    private Sprite[] InjuredSprites; // 攻击状态动画帧序列
    [SerializeField]
    private float frameRate = 0.1f; // 帧更新频率

    private int currentFrame = 0; // 当前动画帧索引
    private Image animatedImage; // UI Image 组件

    private int EnemyHp = 100;

    private Action<int> action;




    private void Awake()
    {
        animatedImage = this.gameObject.GetComponent<Image>();
        if (animatedImage == null)
        {
            print("No Image component!");
        }
    }
    private int m_Index = 0;
    private int a_Index = 0;

    public TimeAction InjuredAction;
    TimeAction IdleAction;
    private State currentState = State.Idle;

    public Slider SliderHP;  //实例化一个Slider

    private int t_Index; // 在父节点下面的索引

    private float HPMaxValue;

    // private int DropedMoney;// 怪物掉落的钱。在EnemyData中处理

    // Start is called before the first frame update
    void Start()
    {
        IdleAction = GameEntry.Time.CreateTimeAction();
        InjuredAction = GameEntry.Time.CreateTimeAction();
        #region 静止动画
        IdleAction.Init(0, 0.1f, -1, () =>
        {
            currentState = State.Idle;
            animatedImage.sprite = idleSprites[m_Index];
        }, (int loop) =>
        {

            if (m_Index == 11) m_Index = 0;
            animatedImage.sprite = idleSprites[m_Index];
            m_Index++;
            //print("m_Index" + m_Index);

        }, null);
        IdleAction.Run();
        #endregion
        #region 受击动画
        InjuredAction.Init(0, 0.03f, 8, () =>
        {
            // 开始运行的回调
            currentState = State.Injured;
            IdleAction.Stop(false);
            a_Index = 0;
            animatedImage.sprite = InjuredSprites[a_Index];
        }, (int loog) =>
        {
            // 每帧执行的回调
            if (a_Index == 7)
                currentState = State.Idle;
            animatedImage.sprite = InjuredSprites[a_Index];
            this.a_Index++;
            //print("a_Index" + a_Index);
        }, () =>
        {
            // 所有次数循环完成的回调
            //Debug.Log("受伤结束");
            IdleAction.Run();
        });
        #endregion

        SliderHP.value = 1;  //Value的值介于0-1之间，且为浮点数

    }

    // 播放受伤动画
    public void Injured(int attackValue)
    {
        InjuredAction.Run();

        float va = (float)attackValue / HPMaxValue;
        print("attackValue是" + attackValue);
        SliderHP.value = SliderHP.value - va;

        if (SliderHP.value <= 0)
        {
            //Enemmy脚本中逻辑
            action(t_Index);
            InjuredAction?.Stop(false);
            SliderHP.value = 1;
            if (t_Index == 4)
            {
                player.GetComponent<Zhuge>().SetToEnemy(0);  
                return;
            }
            print("t_Index" + t_Index);
            player.GetComponent<Zhuge>().SetToEnemy(t_Index +1);

        }
    }
    public void SetEnemyItemUIData(Action<int> AddEnemy,int index,int HP)
    {
        action = AddEnemy;
        t_Index = index;
        // 传血量数据过来
        HPMaxValue = HP; 
    }

    public void UpdateHP(int HP)
    {
        HPMaxValue = HP;
    }


    void Update()
    {
    }

    void OnDestroy()
    {
        if (IdleAction != null)
        {
            IdleAction.Stop(false);
        }
        if (InjuredAction != null)
        {
            InjuredAction.Stop(false);
        }
    }
}
如果这里人物的攻击力大于敌人的血量，导致敌人直接被秒了。这里滑动条的值直接清零了，但是有时候这if (SliderHP.value <= 0)
的逻辑进去不，怎么解决
