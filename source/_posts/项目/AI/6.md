
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;
using System.Collections;
using UnityEditor.Timeline.Actions;

public class Zhuge : MonoBehaviour, IPointerClickHandler
{
    [Header("敌人生成的节点")]
    [SerializeField]
    private Transform EnemyContent;

    [Header("玩家")]
    [SerializeField]
    private GameObject player;

    [Header("子弹")]
    [SerializeField]
    private GameObject bullet;



    [Header("敌人加载出来的父节点")]
    [SerializeField]
    private Transform ContentEnemy;

    public enum State
    {
        Idle,
        Attack,
    }

    [SerializeField]
    private Sprite[] idleSprites; // 普通状态动画帧序列
    [SerializeField]
    private Sprite[] attackSprites; // 攻击状态动画帧序列
    [SerializeField]
    private Sprite[] SpeedSprites; // 连续点击动画帧序列
    [SerializeField]
    private Sprite[] autoSprites; // 攻击状态动画帧序列
    [SerializeField]
    private Sprite[] downGunSprites;

    [SerializeField]
    private float frameRate = 0.1f; // 帧更新频率

  



    private int currentFrame = 0; // 当前动画帧索引
    private Image animatedImage; // UI Image 组件

    public State currentState = State.Idle; // 当前状态

    private void Awake()
    {
        animatedImage = player.GetComponent<Image>();
    }
    private int m_Index = 0;
    private int a_Index = 0;
    private int speed_index = 0;
    private int downGun_index = 0;
    private int auto_Index = 0;


    private TimeAction AttackAction;

    private TimeAction SpeedAction;

    private TimeAction IdleAction;

    private TimeAction DownGunAction;

    private TimeAction AutoAction;

    private TimeAction BulletAction;

    private TimeAction AutoBulletAction;

    private int attackValue = 1; // 角色攻击值

    private void awake()
    {

    }



    //传攻击状态信息到Enemy中，Enemy再传递到每个具体的个人身上
    private void SetToEnemy()
    {
        EnemyContent.gameObject.GetComponent<Enemy>().GetPlayerState();
    }

    public RectTransform bulletRectTransform; // UI元素的RectTransform组件
    public float moveDistance = 10.0f; // 每次移动的距离（像素）
   
    private void Start()
    {

        //DataTableComponent DataObject = GameEntry.DataTable.DataTableManager.Clear;

        //// StartCoroutine(Animate());
        //// 计时器
        #region 静止，开始时候设置为静止状态
        IdleAction = GameEntry.Time.CreateTimeAction();
        IdleAction.Init(0, 0.1f, -1, () =>
        {
            currentState = State.Idle;
            animatedImage.sprite = idleSprites[m_Index];
        }, (int loop) =>
        {

            if (m_Index == 13) m_Index = 0;
            animatedImage.sprite = idleSprites[m_Index];
            m_Index++;
            // print("m_Index" + m_Index);

        }, null);
        #endregion
        IdleAction.Run();

        #region 攻击，开始执行时设置为攻击状态，并且设置bool值，结束执行设置为静止状态，子弹产生。
        AttackAction = GameEntry.Time.CreateTimeAction();
        AttackAction.Init(0, 0.02f, 12, () =>
        {
            currentState = State.Attack;
            IdleAction.Stop(false);
            a_Index = 0;
            isAttackOver = false;

        }, (int loog) =>
        {
            animatedImage.sprite = attackSprites[a_Index];
            a_Index++;
            //print("a_Index" + a_Index);
        }, () =>
        {
            Debug.Log("结束");
            currentState = State.Idle;
            BulletAction.Run();
            isAttackOver = true;
            IdleAction.Run();
        });
        #endregion

        #region 连续攻击，执行结束后设置播放放枪动画
        SpeedAction = GameEntry.Time.CreateTimeAction();
        SpeedAction.Init(0, 0.1f, 3, () =>
        {
            speed_index = 0;
            //BulletAction();
        }, (int loog) =>
        {

            animatedImage.sprite = SpeedSprites[speed_index];
            speed_index++;   
        }, () =>
        {
            currentState = State.Idle;
            IdleAction.Run();
        });
        #endregion

        #region 放下武器片段，在连续攻击最后执行
        DownGunAction = GameEntry.Time.CreateTimeAction();
        DownGunAction.Init(0, 0.1f, 2, () =>
        {
            downGun_index = 0;
        }, (int loog) =>
        {
            animatedImage.sprite = downGunSprites[downGun_index];
            downGun_index++;
        }, () =>
        {
           
        });

        #endregion

        #region 自动攻击,设置isAuto状态为true
        AutoAction = GameEntry.Time.CreateTimeAction();

        AutoAction.Init(0, 0.02f, 300, () =>
        {
            auto_Index = 0;
            isAuto = true;
            // 如果是攻击状态点击加这个保证攻击已经完成
            isAttackOver = true;
        }, (int loog) =>
        {
            if (auto_Index == 8)
            {
                auto_Index = 0;
                AutoBulletAction.Run();
            }
            animatedImage.sprite = autoSprites[auto_Index];
            auto_Index++;
            //print("auto_Index" + auto_Index);

        }, () =>
        {
            Debug.Log("自动攻击结束");
            isAuto = false;
            IdleAction.Run();
        });
        #endregion

        #region 子弹计时器,结束时候消除子弹
        BulletAction = GameEntry.Time.CreateTimeAction();
        BulletAction.Init(0, 0.08f, 3, () =>
        {
            // 开始时的回调，将UI元素重置到初始位置
            bulletRectTransform.anchoredPosition = new Vector2(37, -110f);
            bullet.gameObject.SetActive(true);
        }, (int loop) =>
        {
            // 循环过程中，每次移动UI元素向左
            bulletRectTransform.anchoredPosition += new Vector2(-moveDistance, 0);
        }, () =>
        {
            bullet.gameObject.SetActive(false);
        });
        #endregion

        #region 自动攻击子弹计时器,结束时候消除子弹
        AutoBulletAction = GameEntry.Time.CreateTimeAction();
        AutoBulletAction.Init(0, 0.06f, 3, () =>
        {

            bulletRectTransform.anchoredPosition = new Vector2(37, -96f);
            // 开始时的回调，将UI元素重置到初始位置
            bullet.gameObject.SetActive(true);
        }, (int loop) =>
        {
            // 循环过程中，每次移动UI元素向左
            bulletRectTransform.anchoredPosition += new Vector2(-moveDistance, 0);
        }, () =>
        {
            bullet.gameObject.SetActive(false);
        });
        #endregion
    }

    #region 
    //IEnumerator Animate()
    //{
    //    //小游戏可能不支持while (true) 尽量使用计时器


    //        Sprite[] currentSprites = currentState == State.Attack ? attackSprites : idleSprites;
    //        animatedImage.sprite = currentSprites[currentFrame];

    //        currentFrame = (currentFrame + 1) % currentSprites.Length;

    //        if (currentState == State.Attack && currentFrame == currentSprites.Length - 1)
    //        {
    //            currentState = State.Idle;
    //        }

    //        yield return new WaitForSeconds(frameRate);
    //}
    #endregion

    /// <summary>
    /// 调用攻击的方法
    /// 自动攻击：看一次广告自动攻击多久 总自动攻击时间=每次攻击的时长*攻击次数
    /// </summary>
    /// <param name="eventData"></param>


    // 是否是自动攻击状态
    private bool isAuto = false;
    // 攻击状态是否播放完
    private bool isAttackOver = true;

    //EnemyObject enemyObject = new EnemyObject();


    public void OnPointerClick(PointerEventData eventData)
    {

        print("被点击了");
        if (!isAuto && isAttackOver)
        {
            AutoAction.Stop(false);

            print("现在状态是" + currentState);

            switch (currentState)
            {
                case State.Idle:
                    AudioController.Instance.PlaySfx(AudioController.Instance.attack);
                    // 播放怪物受伤动画
                    ContentEnemy.GetChild(0).GetComponent<EnemyObject>().Injured(attackValue);
                    AttackAction.Run();
                    break;
                case State.Attack:
                    // 如果要一直点一直突。
                    //AttackAction.Stop(false);
                    //SpeedAction.Stop(false);
                    //SpeedAction.Run();
                    break;
                default:
                    break;
            }
        }
    }
    void Update()
    {
        if (Input.GetKeyDown(KeyCode.A))
        {
            AudioController.Instance.PlaySfx(AudioController.Instance.autoAttack);
            IdleAction.Stop(false);
            AttackAction.Stop(false);
            AutoAction.Run();
        }
    }
}


using System;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEditor.Timeline.Actions;
using UnityEngine;
using UnityEngine.EventSystems;
using UnityEngine.UI;

public class EnemyObject : MonoBehaviour, IPointerClickHandler
{
    public enum State
    {
        Idle,
        Injured
    }







    [SerializeField]
    private Sprite[] idleSprites; // 普通状态动画帧序列
    [SerializeField]
    private Sprite[] InjuredSprites; // 攻击状态动画帧序列

    [SerializeField]
    private float frameRate = 0.1f; // 帧更新频率

    private int currentFrame = 0; // 当前动画帧索引
    private Image animatedImage; // UI Image 组件


    private int EnemyHp = 100;

    private Action action;

    private void Awake()
    {
        animatedImage = this.gameObject.GetComponent<Image>();
        if (animatedImage == null)
        {
            print("No Image component!");
        }
    }
    private int m_Index = 0;
    private int a_Index = 0;

    public TimeAction InjuredAction;
    TimeAction IdleAction
        ;
    private State currentState = State.Idle;

    public Slider SliderHP;  //实例化一个Slider

    // Start is called before the first frame update
    void Start()
    {
        IdleAction = GameEntry.Time.CreateTimeAction();
        InjuredAction = GameEntry.Time.CreateTimeAction();
        #region 静止动画
        IdleAction.Init(0, 0.1f, -1, () =>
        {
            currentState = State.Idle;
            animatedImage.sprite = idleSprites[m_Index];
        }, (int loop) =>
        {

            if (m_Index == 11) m_Index = 0;
            animatedImage.sprite = idleSprites[m_Index];
            m_Index++;
            //print("m_Index" + m_Index);

        }, null);
        IdleAction.Run();
        #endregion
        #region 受击动画
        InjuredAction.Init(0, 0.1f, 4, () =>
        {
            // 开始运行的回调
            currentState = State.Injured;
            IdleAction.Stop(false);
            a_Index = 0;
            animatedImage.sprite = InjuredSprites[a_Index];
        }, (int loog) =>
        {
            // 每帧执行的回调
            if (a_Index == 6)
                currentState = State.Idle;
            animatedImage.sprite = InjuredSprites[a_Index];
            this.a_Index++;
            //print("a_Index" + a_Index);
        }, () =>
        {
            // 所有次数循环完成的回调
            Debug.Log("受伤结束");
            IdleAction.Run();
        });
        #endregion

        SliderHP.value = 1;  //Value的值介于0-1之间，且为浮点数

    }

    // 播放受伤动画
    public void Injured(int attackValue)
    {
        InjuredAction.Run();
        EnemyHp -= attackValue;
        int injuredHp = EnemyHp;

        print("injuredHp:" + injuredHp);
        SliderHP.value = SliderHP.value - 0.1f;

        if (SliderHP.value == 0)
        {
            InjuredAction?.Stop(false);
            Destroy(this.gameObject);
            action();
        }
    }
    public void SetEnemyItemUIData(Action AddEnemy)
    {
        action = AddEnemy;   
    }




    void Update()
    {
        if (Input.GetKeyDown(KeyCode.S))  //如果按下A键，血量就会减少
        {
            SliderHP.value = SliderHP.value - 0.1f;
        }
        else if (Input.GetKeyDown(KeyCode.D))  //按下D键，血量就会增加
        {
            SliderHP.value = SliderHP.value + 0.1f;
        }
    }

    void OnDestroy()
    {
        if (IdleAction != null)
        {
            IdleAction.Stop(false);
        }
        if (InjuredAction != null)
        {
            InjuredAction.Stop(false);
        }
    }



    public void OnPointerClick(PointerEventData eventData)
    {
        if (currentState == State.Idle)
        {
            currentState = State.Injured;
            InjuredAction.Run();
        }
    }
}

为什么这两个脚本在计时器方面会有问题
```csharp
using UnityEngine;

public class EnemyUpdater : MonoBehaviour
{
    // 存储要更新的对象的父容器
    public Transform Content;
    // 用于存储累加的 X 轴偏移量
    private float accumulatedXOffset = 0;

    // 更新敌人
    public void UpdateEnemy(int index)
    {
        RectTransform childRectTransform = this.transform.GetChild(index).GetComponent<RectTransform>();
        // 设置 X 坐标
        childRectTransform.anchoredPosition = new Vector2(-600, childRectTransform.anchoredPosition.y);

        // 将当前的移到最后一个
        int lastIndex = Content.childCount - 1;

        for (int i = 0; i < Content.childCount; i++)
        {
            if (i!= index)
            {
                this.transform.GetChild(i).GetComponent<RectTransform>().anchoredPosition += new Vector2(150, 0);
            }
        }
    }

    // 定义回调函数
    private void UpdateEnemyCallback()
    {
        for (int i = 0; i < Content.childCount; i++)
        {
            RectTransform childRectTransform = this.transform.GetChild(i).GetComponent<RectTransform>();
            // 不断累加 X 轴的位置
            accumulatedXOffset += 150; 
            childRectTransform.anchoredPosition += new Vector2(accumulatedXOffset, 0);
        }
    }

    // Unity 的 Update 方法，每帧调用
    void Update()
    {
        UpdateEnemyCallback();
    }
}
```


```C#
using UnityEngine;

public class EnemyUpdater : MonoBehaviour
{
    // 存储移动速度
    public float moveSpeed = 150f;

    // 更新敌人
    public void UpdateEnemy(int index)
    {
        RectTransform childRectTransform = this.transform.GetChild(index).GetComponent<RectTransform>();
        // 设置 X 坐标
        childRectTransform.anchoredPosition = new Vector2(-600, childRectTransform.anchoredPosition.y);

        // 将当前的移到最后一个
        int lastIndex = this.transform.childCount - 1;

        for (int i = 0; i < this.transform.childCount; i++)
        {
            if (i!= index)
            {
                RectTransform rectTransform = this.transform.GetChild(i).GetComponent<RectTransform>();
                // 初始化移动速度
                Vector2 moveDirection = new Vector2(moveSpeed, 0);
                rectTransform.anchoredPosition += moveDirection;
            }
        }
    }

    // Unity 的 Update 方法，每帧调用
    void Update()
    {
        // 遍历所有子对象
        for (int i = 0; i < this.transform.childCount; i++)
        {
            RectTransform rectTransform = this.transform.GetChild(i).GetComponent<RectTransform>();
            // 持续更新位置
            Vector2 moveDirection = new Vector2(moveSpeed * Time.deltaTime, 0);
            rectTransform.anchoredPosition += moveDirection;
        }
    }
}
```

```C#
using UnityEngine;

public class EnemyUpdater : MonoBehaviour
{
    // 存储要更新的对象的父容器
    public Transform Content;

    // 更新敌人
    public void UpdateEnemy(int index)
    {
        RectTransform childRectTransform = this.transform.GetChild(index).GetComponent<RectTransform>();
        // 设置 X 坐标
        childRectTransform.anchoredPosition = new Vector2(-600, childRectTransform.anchoredPosition.y);

        // 将当前的移到最后一个
        int lastIndex = Content.childCount - 1;
    }

    // 定义回调函数，用于更新位置
    private void MoveEnemiesCallback()
    {
        for (int i = 0; i < Content.childCount; i++)
        {
            if (i < Content.childCount)
            {
                RectTransform rectTransform = this.transform.GetChild(i).GetComponent<RectTransform>();
                // 移动敌人
                rectTransform.anchoredPosition += new Vector2(150, 0);
            }
        }
    }

    // Unity 的 Update 方法，每帧调用
    void Update()
    {
        MoveEnemiesCallback();
    }
}
```